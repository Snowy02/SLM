Excellent feedback. You've identified key areas where the UI can be made more professional and user-friendly. I will address all three of your points.

Bug Fix ("LIST CLASSES"): I will fix the bug preventing the class list from appearing. The issue was a mismatch between the Cypher query alias and the data extraction key, combined with a relationship name I had previously corrected. I will revert it to what you likely have in your schema (HAS_CLASSES) and fix the logic.

Scrollable NLP Table: For the "I know what I am doing" path, I will separate the table result from the text explanation. The table will now be rendered in a dedicated gr.DataFrame component, which is inherently scrollable and will no longer break the page layout.

Repository Dependencies Table: For the "I am new to Marketplace" path, I will replace the bulleted list of repository dependencies with a clean, scrollable gr.DataFrame, matching the professional look of the other tables.

Overall Change Explanation

To address your requests, I have made three targeted improvements. First, I fixed the "LIST CLASSES" functionality by correcting the Cypher query's relationship name and ensuring the data extraction logic matches the query's output. Second, for the NLP pathway, I introduced a new gr.DataFrame component to specifically handle and display tabular query results, ensuring they are always scrollable and separate from the textual explanations. Third, I replaced the HTML list for repository-level dependencies with another gr.DataFrame, creating a consistent and cleaner table-based UI across the entire application for dependency viewing.

Complete Working Code
Generated python
#here lies the code of gradio 
import gradio as gr
import pandas as pd
import json
from graph_query_handler import GraphQueryHandler
from data_structures import Node
from typing import Dict,List
import html

custom_theme=gr.themes.Default(
    primary_hue="blue",
    secondary_hue="green",
    neutral_hue="orange",
    text_size="sm",
    font="Comic Sans MS"
)

title_html="""
<div style="text-align: center; margin-top:20px;">
    <h1 style="background: linear-gradient(to right,red,orange,yellow,green,blue,indigo,violet); -webkit-background-clip: text; color:transparent;">
        Codebase Analytica
    </h1>
    <p style="font-size: 18px; color: gray;">Decoding Complexity, One Line at a Time</p>
</div>
"""

def get_query_handler():
    try:
        return GraphQueryHandler()
    except ConnectionError as e:
        print("Error: ",e)
        gr.Error(f"**Failed to initiate connection:** {e}",duration=5)
    return None
query_handler=get_query_handler()
if not query_handler:
    with gr.Blocks(theme=custom_theme)as demo:
        gr.HTML(title_html)
        gr.Error("Could not connect to the database")
    demo.launch()
    import sys
    sys.exit()


with gr.Blocks(theme=custom_theme) as demo:
    # State for conversation data
    chatbot_history_state = gr.State([])
    history_visible_state = gr.State(False)

    gr.HTML(title_html)
    with gr.Sidebar():
        gr.Label("Graph Schema")
        gr.Markdown("A concise summary of the graph schema")
        gr.Markdown(query_handler.concise_schema)
    with gr.Row(visible=True)as main_page:
        user_option=gr.Radio(
            choices=["I am new to Marketplace","I know what I am doing"],
            interactive=True,
            label="Who are you?"
        )
    with gr.Row(visible=False)as repository_row:
        query_for_repositories="MATCH (n:Repository) RETURN DISTINCT n"
        repository_nodes=query_handler.extract_result_for_query(query_for_repositories)
        repositories=[x["n"]["name"] for x in repository_nodes] if repository_nodes else []
        repository_radio=gr.Radio(repositories,label="Select Repository",interactive=True)
    with gr.Row(visible=False)as repository_action_row:
        REPOSITORY_ACTIONS=["LIST CLASSES","LIST DEPENDENCIES"]
        repository_action=gr.Radio(REPOSITORY_ACTIONS,label="What would you like to do?",interactive=True)
    with gr.Row(visible=False)as list_class_row:
        classes_radio_group=gr.Radio(choices=[],label="Select a Class",interactive=True)
    
    # --- START: UI ENHANCEMENT ---
    # 1. Explanation: Changed the component for repository dependencies from gr.HTML to gr.DataFrame.
    # This will render a clean, scrollable table instead of a bulleted list.
    with gr.Row(visible=False) as list_dependencies_row:
        repo_dependency_output = gr.DataFrame(label="Repository Dependencies", visible=False)
    # --- END: UI ENHANCEMENT ---
        
    with gr.Row(visible=False)as class_action_row:
        CLASS_ACTION=['SHOW METHODS','SHOW DEPENDENCIES']
        class_action_radio_group=gr.Radio(CLASS_ACTION,label="Select Action for the chosen class",interactive=True)

    with gr.Row(visible=False) as dependencies_row:
        class_dependency_output = gr.DataFrame(label="Class Dependencies", wrap=True)

    with gr.Row(visible=False)as method_row:
        method_checkbox_group=gr.CheckboxGroup(choices=[],label="Select Method to Explain")
    with gr.Row(visible=False)as explain_code_row:
        explain_code_button=gr.Button(variant="primary",value="Explain Selected Code",interactive=True)
    with gr.Tab(label="Code Explanation",visible=False)as code_explanation_tab:
        with gr.Row():
            code_output=gr.Code(label="Source Code",language="python",interactive=False,scale=1)
            explanation_output=gr.Markdown("LLM Explanation")
            
    with gr.Row(visible=False) as nlp_mode_row:
        with gr.Column():
            gr.Markdown("## Codebase Knowledge Graph Explorer")
            gr.Markdown("Ask a question about your codebase in natural language. The system will convert it to a Cypher query, execute it, and return the answer.")
            with gr.Row():
                nlp_textbox = gr.Textbox(label="Enter your question here:", lines=4, scale=7, placeholder="e.g., 'What are the dependencies for the class X?'")
                nlp_run_button = gr.Button("Run Query", variant="primary", scale=1)

            with gr.Column(visible=False) as nlp_results_col:
                # --- START: UI ENHANCEMENT ---
                # 2. Explanation: Added a dedicated DataFrame component for NLP table results.
                # This ensures large tables are scrollable and don't disrupt the chat flow.
                nlp_dataframe_output = gr.DataFrame(label="Query Result", visible=False, wrap=True)
                # --- END: UI ENHANCEMENT ---
                current_response_output = gr.Markdown(label="Current Response")
                history_button = gr.Button("Show/Hide Conversation History")

            with gr.Row(visible=False) as history_display_row:
                chatbot_output = gr.Chatbot(label="Full Conversation History",bubble_full_width=False,autoscroll=True,height=500)

    guided_mode_components=[
        repository_row,repository_action_row,list_class_row,list_dependencies_row,
        class_action_row,dependencies_row,method_row,explain_code_row,code_explanation_tab,
        repo_dependency_output, class_dependency_output
    ]
    nlp_mode_components = [
        nlp_mode_row, nlp_results_col, chatbot_history_state,
        current_response_output, history_button, history_display_row, chatbot_output,
        history_visible_state, nlp_dataframe_output # Add new component to list
    ]

    def navigation(option):
        updates={}
        updates[main_page]=gr.update(visible=False)
        if option == "I am new to Marketplace":
            updates[repository_row]=gr.update(visible=True)
            for comp in guided_mode_components[1:]+nlp_mode_components:
                updates[comp]=gr.update(visible=False)
            updates[chatbot_history_state] = []
            updates[chatbot_output] = []
            updates[current_response_output] = ""
            updates[history_visible_state] = False
        elif option == "I know what I am doing":
            updates[nlp_mode_row]=gr.update(visible=True)
            for comp in guided_mode_components:
                updates[comp]=gr.update(visible=False)
            updates[chatbot_history_state] = []
            updates[chatbot_output] = []
            updates[current_response_output] = ""
            updates[nlp_results_col] = gr.update(visible=False)
            updates[history_display_row] = gr.update(visible=False)
            updates[history_visible_state] = False
        return updates

    def toggle_history_visibility(is_visible):
        new_visibility = not is_visible
        return gr.update(visible=new_visibility), new_visibility

    def repository_selected_by_user():
        return gr.update(visible=True,value=None)
    def class_selected_by_user():
        return gr.update(visible=True,value=None)
    
    def repository_action_selected_by_user(repository, action):
        if not repository:
            gr.Warning("Please select a repository first.")
            return gr.update(), gr.update(), gr.update(), gr.update()

        if action == "LIST CLASSES":
            # --- START: BUG FIX ---
            # 3. Explanation: Fixed the query and extraction logic.
            # - Reverted relationship name to HAS_CLASSES (as it was in the original code).
            # - Ensured the extraction key 'name' matches the 'c.name as name' alias in the query.
            query = f"MATCH (n:Repository {{name: '{repository}'}})-[:HAS_CLASSES]->(c:Class) RETURN c.name as name"
            result = query_handler.extract_result_for_query(query)
            classes = [x["name"] for x in result] if result else []
            # --- END: BUG FIX ---
            return gr.update(visible=True), gr.update(choices=classes, value=None), gr.update(visible=False, value=None), gr.update(visible=False)
        
        elif action == "LIST DEPENDENCIES":
            # --- START: UI ENHANCEMENT ---
            # 4. Explanation: This block now returns a Pandas DataFrame for the gr.DataFrame component.
            query = f"MATCH (r:Repository {{name: '{repository}'}})-[:DEPENDS_ON]->(dep:Repository) RETURN dep.name as `Depends On`"
            result = query_handler.extract_result_for_query(query)
            
            if result:
                df = pd.DataFrame(result)
                output_df = df
            else:
                gr.Info(f"No repository dependencies found for '{repository}'.")
                output_df = pd.DataFrame()
            
            # Show the dependency table and hide the class list
            return gr.update(visible=False), gr.update(choices=[], value=None), gr.update(visible=True, value=output_df), gr.update(visible=True)
            # --- END: UI ENHANCEMENT ---
        
        return gr.update(visible=False), gr.update(visible=False), gr.update(visible=False), gr.update(visible=False)
    
    def class_action_selected_by_user(repository, class_name, action, progress=gr.Progress(track_tqdm=True)):
        if not class_name:
            gr.Warning("Please select a class first!")
            return gr.update(visible=False), gr.update(visible=False), None, None, gr.update(visible=False)
        
        if action == "SHOW DEPENDENCIES":
            progress(0.1, desc="Querying class dependencies...")
            query = f"""
            MATCH (c:Class {{name: '{class_name}'}})-[:HAS_METHOD]->(m:Method)-[r:CALLS_METHOD]->(target:Method)
            RETURN c.name as Class, m.name as Method, type(r) as Action, target.name as CalledMethod
            """
            result = query_handler.extract_result_for_query(query)
            
            if result:
                df = pd.DataFrame(result)
                output_df = df
            else:
                gr.Info(f"No method dependencies found for class '{class_name}'.")
                output_df = pd.DataFrame()
                
            return gr.update(visible=True), gr.update(visible=False), output_df, gr.update(choices=[], value=None), gr.update(visible=False)

        elif action == "SHOW METHODS":
            progress(0.1, desc="Querying methods...")
            query = f"MATCH (c:Class {{name: '{class_name}'}})-[:HAS_METHOD]->(m:Method) RETURN m.name as name"
            result = query_handler.extract_result_for_query(query)
            methods = [x["name"] for x in result] if result else []
            return gr.update(visible=False), gr.update(visible=True), None, gr.update(choices=methods, value=None), gr.update(visible=True)
        
        return gr.update(visible=False), gr.update(visible=False), None, gr.update(choices=[], value=None), gr.update(visible=False)

    def explain_code_button_handler(selected_methods, class_name):
        if not selected_methods:
            gr.Warning("Please select at least one method to explain.")
            return gr.update(visible=False), None, None, gr.update()
        # ... (rest of function is unchanged)
        method_to_explain = selected_methods[0]
        query = f"MATCH (c:Class {{name: '{class_name}'}})-[:HAS_METHOD]->(m:Method {{name: '{method_to_explain}'}}) RETURN m.source as source"
        result = query_handler.extract_result_for_query(query)

        if result and "source" in result[0]:
            source_code = result[0]["source"]
            yield {
                code_explanation_tab: gr.update(visible=True),
                code_output: gr.update(value=source_code),
                explanation_output: gr.update(value="*Please wait, the LLM is thinking...*"),
                explain_code_button: gr.update(value="Generating Explanation...", interactive=False)
            }
            code_explanation = query_handler.explain_code(source_code)
            yield {
                code_explanation_tab: gr.update(visible=True),
                code_output: gr.update(value=source_code),
                explanation_output: gr.update(value=code_explanation),
                explain_code_button: gr.update(value="Explain Selected Code", interactive=True)
            }
        else:
            gr.Error("Could not retrieve source code for the selected method.")
            yield {
                code_explanation_tab: gr.update(visible=False),
                code_output: None,
                explanation_output: None,
                explain_code_button: gr.update(value="Explain Selected Code", interactive=True)
            }

    # --- START: UI ENHANCEMENT ---
    # 5. Explanation: The NLP handler is modified to separate DataFrame results from text results.
    def handle_nlp_query(question, history, progress=gr.Progress(track_tqdm=True)):
        if not question or not question.strip():
            gr.Warning("Please enter a question before running the query.")
            return "", history, history, gr.update(), "", gr.update(visible=False)

        progress(0, desc="Identifying Intent...")
        bot_response = ""
        # Default updates, assuming no dataframe result
        df_update = gr.update(visible=False, value=None)

        try:
            res = query_handler.identify_intent(question)
            res = res.strip('`').strip('json')
            if not res.strip():
                raise ValueError("Received an empty response from identify_intent")
            response_json = json.loads(res)
            intent = response_json.get("intent")
        except (json.JSONDecodeError, ValueError) as e:
            # ... error handling ...
            error_message = f"Failed to parse response from the language model: {e}"
            print(error_message)
            gr.Error(error_message)
            bot_response = f"<p style='color:red;'>Error: Could not understand the model's response. Details: {html.escape(str(e))}</p>"
            history.append([question, bot_response])
            return "", history, history, gr.update(visible=True), bot_response, df_update

        if intent == "dependency":
            progress(0.3, desc="Generating & running Cypher query...")
            result_data = query_handler.run_query(question)
            final_answer = result_data.get("result")
            
            # 5a. If the result is a list (potential table), create a DataFrame for the dedicated component.
            if isinstance(final_answer, list) and final_answer:
                df = pd.DataFrame(final_answer)
                df_update = gr.update(value=df, visible=True)
            
            # The text part of the response now only contains the execution details.
            bot_response = "<h3>Query Execution Details</h3>"
            bot_response += f"<b>Original Question:</b><p><i>{html.escape(result_data.get('question', 'N/A'))}</i></p>"
            for step in result_data.get('intermediate_steps', []):
                # ... build intermediate steps HTML ...
                status_color = 'green' if step['status'] == 'Success' else 'red'
                bot_response += f"<hr><b>Attempt {step['attempt']}: <span style='color:{status_color};'>{step['status']}</span></b>"
                bot_response += f"<pre><code class='language-cypher'>{html.escape(step['cypher_query'])}</code></pre>"
                if step['status'] != 'Success':
                    bot_response += f"<p style='color:red;'><b>Error:</b> {html.escape(str(step['error']))}</p>"
            if not isinstance(final_answer, list) or not final_answer:
                 bot_response += "<hr><b>Final answer:</b><p>Query executed successfully but returned no results.</p>"
        else: # Handle code explanation
            # ... (this part remains the same, it doesn't produce a table)
            progress(0.3, desc="Extracting entities...")
            entities_str = query_handler.extract_entities(question)
            entities_arr = [e.strip() for e in entities_str.split(",") if e.strip()]
            progress(0.6, desc="Querying graph for entities...")
            query = f"WITH {json.dumps(entities_arr)} AS names MATCH (n) WHERE n.name IN names RETURN n"
            result = query_handler.extract_result_for_query(query=query)
            explanation_html = "<h3>Code Explanations</h3>"
            if not result:
                explanation_html += "<p>Could not find any matching code elements for the entities found.</p>"
            else:
                for item in progress.tqdm(result, desc="Generating explanations..."):
                    node = item.get("n", {})
                    if 'source' in node and 'name' in node:
                        code_explanation = query_handler.explain_code(node["source"])
                        escaped_source = html.escape(node["source"])
                        explanation_html += f"<hr><h4>Explanation for: <code>{html.escape(node['name'])}</code></h4>"
                        explanation_html += f"<pre><code>{escaped_source}</code></pre>"
                        explanation_html += f"<div>{code_explanation}</div>"
            bot_response = explanation_html

        history.append([question, bot_response])
        
        # 5b. Return the separated text response and DataFrame update.
        return "", history, history, gr.update(visible=True), bot_response, df_update
    # --- END: UI ENHANCEMENT ---
    
    all_components=[main_page]+guided_mode_components+nlp_mode_components
    user_option.change(fn=navigation, inputs=user_option, outputs=all_components)
    repository_radio.change(fn=repository_selected_by_user, inputs=None, outputs=[repository_action_row])
    
    # --- START: BUG FIX / UI ENHANCEMENT ---
    # 6. Explanation: The outputs for this event listener are updated to handle the new DataFrame components.
    repository_action.change(
        fn=repository_action_selected_by_user,
        inputs=[repository_radio, repository_action],
        outputs=[list_class_row, classes_radio_group, repo_dependency_output, list_dependencies_row]
    )
    # --- END: BUG FIX / UI ENHANCEMENT ---

    classes_radio_group.change(fn=class_selected_by_user, inputs=None, outputs=[class_action_row])
    class_action_radio_gro
