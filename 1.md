Excellent request. You're looking to refine the user experience by separating the immediate result from the persistent session history, making the interface cleaner and more intuitive. This is a common and valuable pattern in production applications.

I will implement the following changes:

Dedicated "Current Response" Area: The bot's latest response will now appear in a distinct, visible area, ensuring the user immediately sees the answer to their most recent query.

"Conversation History" Button: A new button will be added. The full chat log will be hidden by default.

Toggleable History View: Clicking the button will show or hide the complete conversation history (gr.Chatbot), which is updated in the background after every query.

This architecture provides the best of both worlds: a clean, uncluttered view for the current interaction and easy access to the full session history when needed.

Overall Change Explanation

I have restructured the UI to separate the immediate query response from the full conversation history. A new gr.Markdown component now displays the most recent answer directly below the input box. The complete chat log, stored in a gr.Chatbot component, is now hidden by default within a collapsible row. A new "Show/Hide Conversation History" button uses a small piece of client-side JavaScript to toggle the visibility of this history log without needing a server roundtrip. The backend function handle_nlp_query has been updated to populate both the current response and the history log simultaneously, while the gr.State continues to maintain the session's conversation data.

Complete Working Code
Generated python
#here lies the code of gradio 
import gradio as gr
import pandas as pd
import json
from graph_query_handler import GraphQueryHandler
from data_structures import Node
from typing import Dict,List
import html

custom_theme=gr.themes.Default(
    primary_hue="blue",
    secondary_hue="green",
    neutral_hue="orange",
    text_size="sm",
    font="Comic Sans MS"
)

title_html="""
<div style="text-align: center; margin-top:20px;">
    <h1 style="background: linear-gradient(to right,red,orange,yellow,green,blue,indigo,violet); -webkit-background-clip: text; color:transparent;">
        Codebase Analytica
    </h1>
    <p style="font-size: 18px; color: gray;">Decoding Complexity, One Line at a Time</p>
</div>
"""

def get_query_handler():
    try:
        return GraphQueryHandler()
    except ConnectionError as e:
        print("Error: ",e)
        gr.Error(f"**Failed to initiate connection:** {e}",duration=5)
    return None
query_handler=get_query_handler()
if not query_handler:
    with gr.Blocks(theme=custom_theme)as demo:
        gr.HTML(title_html)
        gr.Error("Could not connect to the database")
    demo.launch()
    import sys
    sys.exit()

# --- START: CHAT HISTORY IMPLEMENTATION V2 ---
# Explanation: A small Javascript function to toggle the visibility of an element.
# This allows the history button to show/hide the chat log on the client-side,
# providing a faster and smoother user experience without a server call.
toggle_js = """
() => {
    const elem = document.getElementById('history_display_row');
    if (elem) {
        elem.style.display = elem.style.display === 'none' ? 'block' : 'none';
    }
}
"""
# --- END: CHAT HISTORY IMPLEMENTATION V2 ---


with gr.Blocks(theme=custom_theme) as demo:
    # 1. Explanation: State component is unchanged. It remains the invisible
    # source of truth for the session's conversation history.
    chatbot_history_state = gr.State([])

    gr.HTML(title_html)
    with gr.Sidebar():
        gr.Label("Graph Schema")
        gr.Markdown("A concise summary of the graph schema")
        gr.Markdown(query_handler.concise_schema)
    with gr.Row(visible=True)as main_page:
        user_option=gr.Radio(
            choices=["I am new to Marketplace","I know what I am doing"],
            interactive=True,
            label="Who are you?"
        )
    with gr.Row(visible=False)as repository_row:
        query_for_repositories="MATCH (n:Repository) RETURN DISTINCT n"
        repository_nodes=query_handler.extract_result_for_query(query_for_repositories)
        repositories=[x["n"]["name"] for x in repository_nodes] if repository_nodes else []
        repository_radio=gr.Radio(repositories,label="Select Repository",interactive=True)
    with gr.Row(visible=False)as repository_action_row:
        REPOSITORY_ACTIONS=["LIST CLASSES","LIST DEPENDENCIES"]
        repository_action=gr.Radio(REPOSITORY_ACTIONS,label="What would you like to do?",interactive=True)
    with gr.Row(visible=False)as list_class_row:
        classes_radio_group=gr.Radio(choices=[],label="Select a Class",interactive=True)
    with gr.Row(visible=False)as list_dependencies_row:
        gr.Markdown("Dependency features for the entire repository can be complex. Please select a specific class first to see its dependencies.")
    with gr.Row(visible=False)as class_action_row:
        CLASS_ACTION=['SHOW METHODS','SHOW DEPENDENCIES']
        class_action_radio_group=gr.Radio(CLASS_ACTION,label="Select Action for the chosen class",interactive=True)
    with gr.Row(visible=False)as dependencies_row:
        html_code_output=gr.HTML(label="Class Dependencies")
    with gr.Row(visible=False)as method_row:
        method_checkbox_group=gr.CheckboxGroup(choices=[],label="Select Method to Explain")
    with gr.Row(visible=False)as explain_code_row:
        explain_code_button=gr.Button(variant="primary",value="Explain Selected Code",interactive=True)
    with gr.Tab(label="Code Explanation",visible=False)as code_explanation_tab:
        with gr.Row():
            code_output=gr.Code(label="Source Code",language="python",interactive=False,scale=1)
            explanation_output=gr.Markdown("LLM Explanation")
            
    with gr.Row(visible=False) as nlp_mode_row:
        with gr.Column():
            gr.Markdown("## Codebase Knowledge Graph Explorer")
            gr.Markdown("Ask a question about your codebase in natural language. The system will convert it to a Cypher query, execute it, and return the answer.")
            with gr.Row():
                nlp_textbox = gr.Textbox(label="Enter your question here:", lines=4, scale=7, placeholder="e.g., 'What are the dependencies for the class X?'")
                nlp_run_button = gr.Button("Run Query", variant="primary", scale=1)

            # --- START: CHAT HISTORY IMPLEMENTATION V2 ---
            # 2. Explanation: A new column to display the results of the CURRENT query.
            # This is separate from the full history.
            with gr.Column(visible=False) as nlp_results_col:
                # 2a. Explanation: A new Markdown component to show the latest bot response.
                # This makes the most recent answer immediately visible to the user.
                current_response_output = gr.Markdown(label="Current Response")
                
                # 2b. Explanation: A button to toggle the visibility of the full history.
                history_button = gr.Button("Show/Hide Conversation History")

            # 3. Explanation: The full conversation history Chatbot is now in its own row.
            # It's hidden by default (`visible=False`) and has a unique `elem_id`
            # so the JavaScript toggle function can find and control it.
            with gr.Row(visible=False, elem_id="history_display_row") as history_display_row:
                chatbot_output = gr.Chatbot(
                    label="Full Conversation History",
                    bubble_full_width=False,
                    autoscroll=True,
                    height=500
                )
            # --- END: CHAT HISTORY IMPLEMENTATION V2 ---

    guided_mode_components=[
        repository_row,repository_action_row,list_class_row,list_dependencies_row,
        class_action_row,dependencies_row,method_row,explain_code_row,code_explanation_tab
    ]
    # 4. Explanation: Added the new UI components to the component list for navigation control.
    nlp_mode_components = [
        nlp_mode_row, nlp_results_col, chatbot_history_state,
        current_response_output, history_button, history_display_row, chatbot_output
    ]

    def navigation(option):
        updates={}
        updates[main_page]=gr.update(visible=False)
        if option == "I am new to Marketplace":
            updates[repository_row]=gr.update(visible=True)
            for comp in guided_mode_components[1:]+nlp_mode_components:
                updates[comp]=gr.update(visible=False)
            # 5. Explanation: Ensure all NLP components, including new ones, are reset and hidden.
            updates[chatbot_history_state] = []
            updates[chatbot_output] = []
            updates[current_response_output] = ""
        elif option == "I know what I am doing":
            updates[nlp_mode_row]=gr.update(visible=True)
            for comp in guided_mode_components:
                updates[comp]=gr.update(visible=False)
            # 6. Explanation: Reset state when switching to this mode.
            updates[chatbot_history_state] = []
            updates[chatbot_output] = []
            updates[current_response_output] = ""
            updates[nlp_results_col] = gr.update(visible=False)
            updates[history_display_row] = gr.update(visible=False) # Ensure history is hidden initially
        return updates
    
    def repository_selected_by_user():
        return gr.update(visible=True,value=None)
    def class_selected_by_user():
        return gr.update(visible=True,value=None)
    def repository_action_selected_by_user(repository,action):
        if action =="LIST CLASSES":
            query=f"MATCH(n:Repository {{name: '{repository}'}})-[HAS_CLASSES]->(c:Class) RETURN c.name as name"
            result=query_handler.extract_result_for_query(query)
            classes=[x["c"]["name"] for x in result] if result else []
            return gr.update(visible=True),gr.update(choices=classes,value=None),gr.update(visible=False)
        elif action =="LIST DEPENDENCIES":
            return gr.update(visible=False),gr.update(choices=[],value=None),gr.update(visible=True)
        return gr.update(visible=False),gr.update(visible=False)
    def class_action_selected_by_user(repository,class_name,action,progress=gr.Progress(track_tqdm=True)):
        if not class_name:
            gr.Warning("Please Select a class first!")
            return gr.update(visible=False),gr.update(visible=False),None,None,gr.update(visible=False)
        if action == "SHOW DEPENDENCIES":
            progress(0.1,desc="Querying dependencies...")
            query=f"MATCH (c:Class {{name: '{class_name}}})-[r:HAS_METHOD]->(m:Method)-[r2:CALLS_METHOD]->(target:Method) RETURN c.name as Class,m.name as Method,type(r2)as Action,target.name as CalledMethod"
            result=query_handler.extract_result_for_query(query)
            if result:
                df=pd.DataFrame(result)
                html_code=df.to_html(index=False,justify='center',border=1,classes="gr-dataframe")
            else:
                html_code="<p style='text-align:center;color:gray;'>No dependencies found for this class.</p>"
            return gr.update(visible=True),gr.update(visible=False),html_code,gr.update(choices=[],value=None),None,gr.update(visible=False)
        elif action == "SHOW METHODS":
            progress(0.1,desc="Querying methods...")
            query=f"MATCH (c:Class {{name: '{class_name}'}})-[:HAS_METHOD]->(m:Method) RETURN m.name as name"
            result=query_handler.extract_result_for_query(query)
            methods=[x["m.name"] for x in result] if result else []
            return gr.update(visible=False),gr.update(visible=True),None,gr.update(choices=methods,value=None),gr.update(visible=True)
        return gr.update(visible=False),gr.update(visible=False),None,gr.update(choices=[],value=None),gr.update(visible=False)
    def explain_code_button_handler(selected_methods,class_name): # Removed unused 'repository' parameter
        if not selected_methods:
            gr.Warning("Please select at least one method to explain")
            return gr.update(visible=False),None,None
        method_to_explain=selected_methods[0]
        query=f"MATCH (c:Class {{name: '{class_name}'}})-[:HAS_METHOD]->(m:Method {{name: '{method_to_explain}'}}) RETURN m.source as source"
        result=query_handler.extract_result_for_query(query)
        if result and "source" in result[0]:
            source_code=result[0]["source"]
            code_explanation=query_handler.explain_code(source_code)
            return gr.update(visible=True),gr.update(value=source_code),gr.update(value=code_explanation)
        else:
            gr.Error("Could not retrieve source code for the selected method.")
            return gr.update(visible=False),None,None

    # --- START: CHAT HISTORY IMPLEMENTATION V2 ---
    # 7. Explanation: The core logic function is updated.
    # It now returns the new bot_response separately to populate the 'current_response_output',
    # while also returning the full history to update the hidden chatbot and the state.
    def handle_nlp_query(question, history, progress=gr.Progress(track_tqdm=True)):
        if not question or not question.strip():
            gr.Warning("Please enter a question before running the query.")
            return "", history, history, gr.update(), ""

        progress(0, desc="Identifying Intent...")
        bot_response = ""
        try:
            res = query_handler.identify_intent(question)
            res = res.strip('`').strip('json')
            if not res.strip():
                raise ValueError("Received an empty response from identify_intent")
            response_json = json.loads(res)
            intent = response_json.get("intent")
        except (json.JSONDecodeError, ValueError) as e:
            error_message = f"Failed to parse response from the language model: {e}"
            print(error_message)
            gr.Error(error_message)
            bot_response = f"<p style='color:red;'>Error: Could not understand the model's response. Details: {html.escape(str(e))}</p>"
            history.append([question, bot_response])
            return "", history, history, gr.update(visible=True), bot_response

        if intent == "dependency":
            progress(0.3, desc="Generating & running Cypher query...")
            result_data = query_handler.run_query(question)
            
            final_answer = result_data.get("result")
            df_markdown = ""
            if isinstance(final_answer, list) and final_answer:
                df = pd.DataFrame(final_answer)
                df_markdown = "### Query Result\n" + df.to_markdown(index=False) + "\n\n<hr>"

            intermediate_html = "<h3>Query Execution Details</h3>"
            intermediate_html += f"<b>Original Question:</b><p><i>{html.escape(result_data.get('question', 'N/A'))}</i></p>"
            for step in result_data.get('intermediate_steps', []):
                status_color = 'green' if step['status'] == 'Success' else 'red'
                intermediate_html += f"<hr><b>Attempt {step['attempt']}: <span style='color:{status_color};'>{step['status']}</span></b>"
                intermediate_html += f"<pre><code class='language-cypher'>{html.escape(step['cypher_query'])}</code></pre>"
                if step['status'] != 'Success':
                    intermediate_html += f"<p style='color:red;'><b>Error:</b> {html.escape(str(step['error']))}</p>"
            if not df_markdown:
                 intermediate_html += "<hr><b>Final answer:</b><p>Query executed successfully but returned no results.</p>"
            
            bot_response = df_markdown + intermediate_html
        else:
            progress(0.3, desc="Extracting entities...")
            entities_str = query_handler.extract_entities(question)
            entities_arr = [e.strip() for e in entities_str.split(",") if e.strip()]
            progress(0.6, desc="Querying graph for entities...")
            query = f"WITH {json.dumps(entities_arr)} AS names MATCH (n) WHERE n.name IN names RETURN n"
            result = query_handler.extract_result_for_query(query=query)
            
            explanation_html = "<h3>Code Explanations</h3>"
            if not result:
                explanation_html += "<p>Could not find any matching code elements for the entities found.</p>"
            else:
                for item in progress.tqdm(result, desc="Generating explanations..."):
                    node = item.get("n", {})
                    if 'source' in node and 'name' in node:
                        code_explanation = query_handler.explain_code(node["source"])
                        escaped_source = html.escape(node["source"])
                        explanation_html += f"<hr><h4>Explanation for: <code>{html.escape(node['name'])}</code></h4>"
                        explanation_html += f"<pre><code>{escaped_source}</code></pre>"
                        explanation_html += f"<div>{code_explanation}</div>"
            bot_response = explanation_html

        history.append([question, bot_response])
        
        # Return updates for all relevant components
        return "", history, history, gr.update(visible=True), bot_response
    # --- END: CHAT HISTORY IMPLEMENTATION V2 ---
    
    all_components=[main_page]+guided_mode_components+nlp_mode_components
    user_option.change(
        fn=navigation,
        inputs=user_option,
        outputs=all_components
    )
    repository_radio.change(fn=repository_selected_by_user,inputs=None,outputs=[repository_action_row])
    repository_action.change(fn=repository_action_selected_by_user,inputs=[repository_radio,repository_action],outputs=[list_class_row,classes_radio_group,list_dependencies_row])
    classes_radio_group.change(fn=class_selected_by_user,inputs=None,outputs=[class_action_row])
    class_action_radio_group.change(fn=class_action_selected_by_user,inputs=[repository_radio,classes_radio_group,class_action_radio_group],outputs=[dependencies_row,method_row,html_code_output,method_checkbox_group,explain_code_row])
    explain_code_button.click(fn=explain_code_button_handler,inputs=[method_checkbox_group,classes_radio_group],outputs=[code_explanation_tab,code_output,explanation_output])

    # --- START: CHAT HISTORY IMPLEMENTATION V2 ---
    # 8. Explanation: The button click for toggling history uses the `_js` argument.
    # This runs the JavaScript function directly in the browser for a seamless toggle.
    history_button.click(fn=None, _js=toggle_js)

    # 9. Explanation: The event handlers for submitting a query are updated.
    # The 'outputs' list now includes the new `current_response_output` to display the immediate answer.
    nlp_textbox.submit(
        fn=handle_nlp_query,
        inputs=[nlp_textbox, chatbot_history_state],
        outputs=[nlp_textbox, chatbot_output, chatbot_history_state, nlp_results_col, current_response_output]
    )
    nlp_run_button.click(
        fn=handle_nlp_query,
        inputs=[nlp_textbox, chatbot_history_state],
        outputs=[nlp_textbox, chatbot_output, chatbot_history_state, nlp_results_col, current_response_output]
    )
    # --- END: CHAT HISTORY IMPLEMENTATION V2 ---

demo.launch(debug=True)
