You've encountered a very common compatibility issue. My apologies, I should have anticipated this.

The error TypeError: event_trigger() got an unexpected keyword argument '_js' almost always means that the version of Gradio you have installed is slightly older and doesn't support the _js argument for running client-side JavaScript directly.

The best and most modern solution is to upgrade your Gradio library:
pip install --upgrade gradio

However, a robust solution should not depend on the user having the latest version. I will provide a fully working, backward-compatible solution that achieves the exact same result using only server-side Python, which will work on any Gradio version.

Explanation of the Fix

Instead of using JavaScript, we will manage the visibility of the history panel using a gr.State variable.

New State Variable: I'll add a history_visible_state = gr.State(False) to keep track of whether the history panel is currently shown or hidden.

New Python Function: I'll create a simple Python function called toggle_history_visibility. When the "Show/Hide" button is clicked, this function will run. It will check the current state (e.g., False) and return the opposite (True), along with a gr.update(visible=True) to update the UI.

Updated Button Click Event: The history_button.click() event will now call this new Python function instead of using the _js argument.

This approach is more resilient and accomplishes the same goal of toggling the history view on and off.

Complete Backward-Compatible Code

Here is the complete, updated code with the fix implemented.

Generated python
#here lies the code of gradio 
import gradio as gr
import pandas as pd
import json
from graph_query_handler import GraphQueryHandler
from data_structures import Node
from typing import Dict,List
import html

custom_theme=gr.themes.Default(
    primary_hue="blue",
    secondary_hue="green",
    neutral_hue="orange",
    text_size="sm",
    font="Comic Sans MS"
)

title_html="""
<div style="text-align: center; margin-top:20px;">
    <h1 style="background: linear-gradient(to right,red,orange,yellow,green,blue,indigo,violet); -webkit-background-clip: text; color:transparent;">
        Codebase Analytica
    </h1>
    <p style="font-size: 18px; color: gray;">Decoding Complexity, One Line at a Time</p>
</div>
"""

def get_query_handler():
    try:
        return GraphQueryHandler()
    except ConnectionError as e:
        print("Error: ",e)
        gr.Error(f"**Failed to initiate connection:** {e}",duration=5)
    return None
query_handler=get_query_handler()
if not query_handler:
    with gr.Blocks(theme=custom_theme)as demo:
        gr.HTML(title_html)
        gr.Error("Could not connect to the database")
    demo.launch()
    import sys
    sys.exit()


with gr.Blocks(theme=custom_theme) as demo:
    # State for conversation data
    chatbot_history_state = gr.State([])

    # --- START: BACKWARD-COMPATIBLE FIX ---
    # 1. Explanation: Added a new State variable to track the visibility of the history panel.
    # This replaces the need for client-side JavaScript.
    history_visible_state = gr.State(False)
    # --- END: BACKWARD-COMPATIBLE FIX ---


    gr.HTML(title_html)
    with gr.Sidebar():
        gr.Label("Graph Schema")
        gr.Markdown("A concise summary of the graph schema")
        gr.Markdown(query_handler.concise_schema)
    with gr.Row(visible=True)as main_page:
        user_option=gr.Radio(
            choices=["I am new to Marketplace","I know what I am doing"],
            interactive=True,
            label="Who are you?"
        )
    with gr.Row(visible=False)as repository_row:
        query_for_repositories="MATCH (n:Repository) RETURN DISTINCT n"
        repository_nodes=query_handler.extract_result_for_query(query_for_repositories)
        repositories=[x["n"]["name"] for x in repository_nodes] if repository_nodes else []
        repository_radio=gr.Radio(repositories,label="Select Repository",interactive=True)
    with gr.Row(visible=False)as repository_action_row:
        REPOSITORY_ACTIONS=["LIST CLASSES","LIST DEPENDENCIES"]
        repository_action=gr.Radio(REPOSITORY_ACTIONS,label="What would you like to do?",interactive=True)
    with gr.Row(visible=False)as list_class_row:
        classes_radio_group=gr.Radio(choices=[],label="Select a Class",interactive=True)
    with gr.Row(visible=False)as list_dependencies_row:
        gr.Markdown("Dependency features for the entire repository can be complex. Please select a specific class first to see its dependencies.")
    with gr.Row(visible=False)as class_action_row:
        CLASS_ACTION=['SHOW METHODS','SHOW DEPENDENCIES']
        class_action_radio_group=gr.Radio(CLASS_ACTION,label="Select Action for the chosen class",interactive=True)
    with gr.Row(visible=False)as dependencies_row:
        html_code_output=gr.HTML(label="Class Dependencies")
    with gr.Row(visible=False)as method_row:
        method_checkbox_group=gr.CheckboxGroup(choices=[],label="Select Method to Explain")
    with gr.Row(visible=False)as explain_code_row:
        explain_code_button=gr.Button(variant="primary",value="Explain Selected Code",interactive=True)
    with gr.Tab(label="Code Explanation",visible=False)as code_explanation_tab:
        with gr.Row():
            code_output=gr.Code(label="Source Code",language="python",interactive=False,scale=1)
            explanation_output=gr.Markdown("LLM Explanation")
            
    with gr.Row(visible=False) as nlp_mode_row:
        with gr.Column():
            gr.Markdown("## Codebase Knowledge Graph Explorer")
            gr.Markdown("Ask a question about your codebase in natural language. The system will convert it to a Cypher query, execute it, and return the answer.")
            with gr.Row():
                nlp_textbox = gr.Textbox(label="Enter your question here:", lines=4, scale=7, placeholder="e.g., 'What are the dependencies for the class X?'")
                nlp_run_button = gr.Button("Run Query", variant="primary", scale=1)

            with gr.Column(visible=False) as nlp_results_col:
                current_response_output = gr.Markdown(label="Current Response")
                history_button = gr.Button("Show/Hide Conversation History")

            # This row is now controlled by the new Python toggle function
            with gr.Row(visible=False) as history_display_row:
                chatbot_output = gr.Chatbot(
                    label="Full Conversation History",
                    bubble_full_width=False,
                    autoscroll=True,
                    height=500
                )

    guided_mode_components=[
        repository_row,repository_action_row,list_class_row,list_dependencies_row,
        class_action_row,dependencies_row,method_row,explain_code_row,code_explanation_tab
    ]
    nlp_mode_components = [
        nlp_mode_row, nlp_results_col, chatbot_history_state,
        current_response_output, history_button, history_display_row, chatbot_output,
        history_visible_state # Add new state to the list
    ]

    def navigation(option):
        updates={}
        updates[main_page]=gr.update(visible=False)
        if option == "I am new to Marketplace":
            updates[repository_row]=gr.update(visible=True)
            for comp in guided_mode_components[1:]+nlp_mode_components:
                updates[comp]=gr.update(visible=False)
            updates[chatbot_history_state] = []
            updates[chatbot_output] = []
            updates[current_response_output] = ""
            updates[history_visible_state] = False
        elif option == "I know what I am doing":
            updates[nlp_mode_row]=gr.update(visible=True)
            for comp in guided_mode_components:
                updates[comp]=gr.update(visible=False)
            updates[chatbot_history_state] = []
            updates[chatbot_output] = []
            updates[current_response_output] = ""
            updates[nlp_results_col] = gr.update(visible=False)
            updates[history_display_row] = gr.update(visible=False)
            updates[history_visible_state] = False
        return updates

    # --- START: BACKWARD-COMPATIBLE FIX ---
    # 2. Explanation: This new Python function handles the logic for showing/hiding the history panel.
    # It takes the current visibility state as input and returns the opposite state.
    def toggle_history_visibility(is_visible):
        # Invert the state
        new_visibility = not is_visible
        # Return an update for the UI component and the new state value
        return gr.update(visible=new_visibility), new_visibility
    # --- END: BACKWARD-COMPATIBLE FIX ---

    def repository_selected_by_user():
        return gr.update(visible=True,value=None)
    def class_selected_by_user():
        return gr.update(visible=True,value=None)
    def repository_action_selected_by_user(repository,action):
        if action =="LIST CLASSES":
            query=f"MATCH(n:Repository {{name: '{repository}'}})-[HAS_CLASSES]->(c:Class) RETURN c.name as name"
            result=query_handler.extract_result_for_query(query)
            classes=[x["c"]["name"] for x in result] if result else []
            return gr.update(visible=True),gr.update(choices=classes,value=None),gr.update(visible=False)
        elif action =="LIST DEPENDENCIES":
            return gr.update(visible=False),gr.update(choices=[],value=None),gr.update(visible=True)
        return gr.update(visible=False),gr.update(visible=False)
    def class_action_selected_by_user(repository,class_name,action,progress=gr.Progress(track_tqdm=True)):
        if not class_name:
            gr.Warning("Please Select a class first!")
            return gr.update(visible=False),gr.update(visible=False),None,None,gr.update(visible=False)
        if action == "SHOW DEPENDENCIES":
            progress(0.1,desc="Querying dependencies...")
            query=f"MATCH (c:Class {{name: '{class_name}}})-[r:HAS_METHOD]->(m:Method)-[r2:CALLS_METHOD]->(target:Method) RETURN c.name as Class,m.name as Method,type(r2)as Action,target.name as CalledMethod"
            result=query_handler.extract_result_for_query(query)
            if result:
                df=pd.DataFrame(result)
                html_code=df.to_html(index=False,justify='center',border=1,classes="gr-dataframe")
            else:
                html_code="<p style='text-align:center;color:gray;'>No dependencies found for this class.</p>"
            return gr.update(visible=True),gr.update(visible=False),html_code,gr.update(choices=[],value=None),None,gr.update(visible=False)
        elif action == "SHOW METHODS":
            progress(0.1,desc="Querying methods...")
            query=f"MATCH (c:Class {{name: '{class_name}'}})-[:HAS_METHOD]->(m:Method) RETURN m.name as name"
            result=query_handler.extract_result_for_query(query)
            methods=[x["m.name"] for x in result] if result else []
            return gr.update(visible=False),gr.update(visible=True),None,gr.update(choices=methods,value=None),gr.update(visible=True)
        return gr.update(visible=False),gr.update(visible=False),None,gr.update(choices=[],value=None),gr.update(visible=False)
    def explain_code_button_handler(selected_methods,class_name):
        if not selected_methods:
            gr.Warning("Please select at least one method to explain")
            return gr.update(visible=False),None,None
        method_to_explain=selected_methods[0]
        query=f"MATCH (c:Class {{name: '{class_name}'}})-[:HAS_METHOD]->(m:Method {{name: '{method_to_explain}'}}) RETURN m.source as source"
        result=query_handler.extract_result_for_query(query)
        if result and "source" in result[0]:
            source_code=result[0]["source"]
            code_explanation=query_handler.explain_code(source_code)
            return gr.update(visible=True),gr.update(value=source_code),gr.update(value=code_explanation)
        else:
            gr.Error("Could not retrieve source code for the selected method.")
            return gr.update(visible=False),None,None

    def handle_nlp_query(question, history, progress=gr.Progress(track_tqdm=True)):
        if not question or not question.strip():
            gr.Warning("Please enter a question before running the query.")
            return "", history, history, gr.update(), ""

        progress(0, desc="Identifying Intent...")
        bot_response = ""
        try:
            res = query_handler.identify_intent(question)
            res = res.strip('`').strip('json')
            if not res.strip():
                raise ValueError("Received an empty response from identify_intent")
            response_json = json.loads(res)
            intent = response_json.get("intent")
        except (json.JSONDecodeError, ValueError) as e:
            error_message = f"Failed to parse response from the language model: {e}"
            print(error_message)
            gr.Error(error_message)
            bot_response = f"<p style='color:red;'>Error: Could not understand the model's response. Details: {html.escape(str(e))}</p>"
            history.append([question, bot_response])
            return "", history, history, gr.update(visible=True), bot_response

        if intent == "dependency":
            progress(0.3, desc="Generating & running Cypher query...")
            result_data = query_handler.run_query(question)
            
            final_answer = result_data.get("result")
            df_markdown = ""
            if isinstance(final_answer, list) and final_answer:
                df = pd.DataFrame(final_answer)
                df_markdown = "### Query Result\n" + df.to_markdown(index=False) + "\n\n<hr>"

            intermediate_html = "<h3>Query Execution Details</h3>"
            intermediate_html += f"<b>Original Question:</b><p><i>{html.escape(result_data.get('question', 'N/A'))}</i></p>"
            for step in result_data.get('intermediate_steps', []):
                status_color = 'green' if step['status'] == 'Success' else 'red'
                intermediate_html += f"<hr><b>Attempt {step['attempt']}: <span style='color:{status_color};'>{step['status']}</span></b>"
                intermediate_html += f"<pre><code class='language-cypher'>{html.escape(step['cypher_query'])}</code></pre>"
                if step['status'] != 'Success':
                    intermediate_html += f"<p style='color:red;'><b>Error:</b> {html.escape(str(step['error']))}</p>"
            if not df_markdown:
                 intermediate_html += "<hr><b>Final answer:</b><p>Query executed successfully but returned no results.</p>"
            
            bot_response = df_markdown + intermediate_html
        else:
            progress(0.3, desc="Extracting entities...")
            entities_str = query_handler.extract_entities(question)
            entities_arr = [e.strip() for e in entities_str.split(",") if e.strip()]
            progress(0.6, desc="Querying graph for entities...")
            query = f"WITH {json.dumps(entities_arr)} AS names MATCH (n) WHERE n.name IN names RETURN n"
            result = query_handler.extract_result_for_query(query=query)
            
            explanation_html = "<h3>Code Explanations</h3>"
            if not result:
                explanation_html += "<p>Could not find any matching code elements for the entities found.</p>"
            else:
                for item in progress.tqdm(result, desc="Generating explanations..."):
                    node = item.get("n", {})
                    if 'source' in node and 'name' in node:
                        code_explanation = query_handler.explain_code(node["source"])
                        escaped_source = html.escape(node["source"])
                        explanation_html += f"<hr><h4>Explanation for: <code>{html.escape(node['name'])}</code></h4>"
                        explanation_html += f"<pre><code>{escaped_source}</code></pre>"
                        explanation_html += f"<div>{code_explanation}</div>"
            bot_response = explanation_html

        history.append([question, bot_response])
        
        return "", history, history, gr.update(visible=True), bot_response
    
    all_components=[main_page]+guided_mode_components+nlp_mode_components
    user_option.change(
        fn=navigation,
        inputs=user_option,
        outputs=all_components
    )
    repository_radio.change(fn=repository_selected_by_user,inputs=None,outputs=[repository_action_row])
    repository_action.change(fn=repository_action_selected_by_user,inputs=[repository_radio,repository_action],outputs=[list_class_row,classes_radio_group,list_dependencies_row])
    classes_radio_group.change(fn=class_selected_by_user,inputs=None,outputs=[class_action_row])
    class_action_radio_group.change(fn=class_action_selected_by_user,inputs=[repository_radio,classes_radio_group,class_action_radio_group],outputs=[dependencies_row,method_row,html_code_output,method_checkbox_group,explain_code_row])
    explain_code_button.click(fn=explain_code_button_handler,inputs=[method_checkbox_group,classes_radio_group],outputs=[code_explanation_tab,code_output,explanation_output])

    # --- START: BACKWARD-COMPATIBLE FIX ---
    # 3. Explanation: The button's click event is changed. It now calls our new Python function.
    # It takes the visibility state as input and updates both the UI row and the state variable as output.
    history_button.click(
        fn=toggle_history_visibility,
        inputs=[history_visible_state],
        outputs=[history_display_row, history_visible_state]
    )
    # --- END: BACKWARD-COMPATIBLE FIX ---

    nlp_textbox.submit(
        fn=handle_nlp_query,
        inputs=[nlp_textbox, chatbot_history_state],
        outputs=[nlp_textbox, chatbot_output, chatbot_history_state, nlp_results_col, current_response_output]
    )
    nlp_run_button.click(
        fn=handle_nlp_query,
        inputs=[nlp_textbox, chatbot_history_state],
        outputs=[nlp_textbox, chatbot_output, chatbot_history_state, nlp_results_col, current_response_output]
    )

demo.launch(debug=True)
