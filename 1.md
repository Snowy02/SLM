Of course. Adding clear feedback for background processes is crucial for a good user experience. I will implement a loading indicator for the "Explain Selected Code" button.

I will achieve this by modifying the explain_code_button_handler function to do the following:

Immediately Disable Button: As soon as the button is clicked, it will be disabled and its text will change to "Generating Explanation...". This provides instant feedback and prevents multiple clicks.

Use yield for Intermediate Updates: The function will use yield to send this initial "loading" state to the UI before calling the time-consuming LLM function.

Show Loading Text: The output area will immediately become visible and display a "Please wait..." message.

Re-enable Button on Completion: Once the LLM response is received, the function will send a final update that populates the result and restores the button to its original, clickable state.

This yield-based approach is the standard Gradio pattern for handling long-running tasks gracefully.

Overall Change Explanation

To provide user feedback during processing, I have converted the explain_code_button_handler function into a Python generator using the yield keyword. When the "Explain Selected Code" button is clicked, it now immediately yields a UI update that changes the button's text to "Generating Explanation...", disables it, and shows a loading message in the output panel. After the time-consuming code explanation is generated, the function yields a final update with the result, simultaneously re-enabling the button and resetting its text. To enable this, the button itself has been added to the inputs and outputs of its own .click() event listener, allowing the function to control its state.

Complete Working Code
Generated python
#here lies the code of gradio 
import gradio as gr
import pandas as pd
import json
from graph_query_handler import GraphQueryHandler
from data_structures import Node
from typing import Dict,List
import html

custom_theme=gr.themes.Default(
    primary_hue="blue",
    secondary_hue="green",
    neutral_hue="orange",
    text_size="sm",
    font="Comic Sans MS"
)

title_html="""
<div style="text-align: center; margin-top:20px;">
    <h1 style="background: linear-gradient(to right,red,orange,yellow,green,blue,indigo,violet); -webkit-background-clip: text; color:transparent;">
        Codebase Analytica
    </h1>
    <p style="font-size: 18px; color: gray;">Decoding Complexity, One Line at a Time</p>
</div>
"""

def get_query_handler():
    try:
        return GraphQueryHandler()
    except ConnectionError as e:
        print("Error: ",e)
        gr.Error(f"**Failed to initiate connection:** {e}",duration=5)
    return None
query_handler=get_query_handler()
if not query_handler:
    with gr.Blocks(theme=custom_theme)as demo:
        gr.HTML(title_html)
        gr.Error("Could not connect to the database")
    demo.launch()
    import sys
    sys.exit()


with gr.Blocks(theme=custom_theme) as demo:
    # State for conversation data
    chatbot_history_state = gr.State([])
    history_visible_state = gr.State(False)

    gr.HTML(title_html)
    with gr.Sidebar():
        gr.Label("Graph Schema")
        gr.Markdown("A concise summary of the graph schema")
        gr.Markdown(query_handler.concise_schema)
    with gr.Row(visible=True)as main_page:
        user_option=gr.Radio(
            choices=["I am new to Marketplace","I know what I am doing"],
            interactive=True,
            label="Who are you?"
        )
    with gr.Row(visible=False)as repository_row:
        query_for_repositories="MATCH (n:Repository) RETURN DISTINCT n"
        repository_nodes=query_handler.extract_result_for_query(query_for_repositories)
        repositories=[x["n"]["name"] for x in repository_nodes] if repository_nodes else []
        repository_radio=gr.Radio(repositories,label="Select Repository",interactive=True)
    with gr.Row(visible=False)as repository_action_row:
        REPOSITORY_ACTIONS=["LIST CLASSES","LIST DEPENDENCIES"]
        repository_action=gr.Radio(REPOSITORY_ACTIONS,label="What would you like to do?",interactive=True)
    with gr.Row(visible=False)as list_class_row:
        classes_radio_group=gr.Radio(choices=[],label="Select a Class",interactive=True)
    with gr.Row(visible=False)as list_dependencies_row:
        gr.Markdown("Dependency features for the entire repository can be complex. Please select a specific class first to see its dependencies.")
    with gr.Row(visible=False)as class_action_row:
        CLASS_ACTION=['SHOW METHODS','SHOW DEPENDENCIES']
        class_action_radio_group=gr.Radio(CLASS_ACTION,label="Select Action for the chosen class",interactive=True)
    with gr.Row(visible=False)as dependencies_row:
        html_code_output=gr.HTML(label="Class Dependencies")
    with gr.Row(visible=False)as method_row:
        method_checkbox_group=gr.CheckboxGroup(choices=[],label="Select Method to Explain")
    with gr.Row(visible=False)as explain_code_row:
        explain_code_button=gr.Button(variant="primary",value="Explain Selected Code",interactive=True)
    with gr.Tab(label="Code Explanation",visible=False)as code_explanation_tab:
        with gr.Row():
            code_output=gr.Code(label="Source Code",language="python",interactive=False,scale=1)
            explanation_output=gr.Markdown("LLM Explanation")
            
    with gr.Row(visible=False) as nlp_mode_row:
        with gr.Column():
            gr.Markdown("## Codebase Knowledge Graph Explorer")
            gr.Markdown("Ask a question about your codebase in natural language. The system will convert it to a Cypher query, execute it, and return the answer.")
            with gr.Row():
                nlp_textbox = gr.Textbox(label="Enter your question here:", lines=4, scale=7, placeholder="e.g., 'What are the dependencies for the class X?'")
                nlp_run_button = gr.Button("Run Query", variant="primary", scale=1)

            with gr.Column(visible=False) as nlp_results_col:
                current_response_output = gr.Markdown(label="Current Response")
                history_button = gr.Button("Show/Hide Conversation History")

            with gr.Row(visible=False) as history_display_row:
                chatbot_output = gr.Chatbot(
                    label="Full Conversation History",
                    bubble_full_width=False,
                    autoscroll=True,
                    height=500
                )

    guided_mode_components=[
        repository_row,repository_action_row,list_class_row,list_dependencies_row,
        class_action_row,dependencies_row,method_row,explain_code_row,code_explanation_tab
    ]
    nlp_mode_components = [
        nlp_mode_row, nlp_results_col, chatbot_history_state,
        current_response_output, history_button, history_display_row, chatbot_output,
        history_visible_state
    ]

    def navigation(option):
        updates={}
        updates[main_page]=gr.update(visible=False)
        if option == "I am new to Marketplace":
            updates[repository_row]=gr.update(visible=True)
            for comp in guided_mode_components[1:]+nlp_mode_components:
                updates[comp]=gr.update(visible=False)
            updates[chatbot_history_state] = []
            updates[chatbot_output] = []
            updates[current_response_output] = ""
            updates[history_visible_state] = False
        elif option == "I know what I am doing":
            updates[nlp_mode_row]=gr.update(visible=True)
            for comp in guided_mode_components:
                updates[comp]=gr.update(visible=False)
            updates[chatbot_history_state] = []
            updates[chatbot_output] = []
            updates[current_response_output] = ""
            updates[nlp_results_col] = gr.update(visible=False)
            updates[history_display_row] = gr.update(visible=False)
            updates[history_visible_state] = False
        return updates

    def toggle_history_visibility(is_visible):
        new_visibility = not is_visible
        return gr.update(visible=new_visibility), new_visibility

    def repository_selected_by_user():
        return gr.update(visible=True,value=None)
    def class_selected_by_user():
        return gr.update(visible=True,value=None)
    def repository_action_selected_by_user(repository,action):
        if action =="LIST CLASSES":
            query=f"MATCH(n:Repository {{name: '{repository}'}})-[HAS_CLASSES]->(c:Class) RETURN c.name as name"
            result=query_handler.extract_result_for_query(query)
            classes=[x["c"]["name"] for x in result] if result else []
            return gr.update(visible=True),gr.update(choices=classes,value=None),gr.update(visible=False)
        elif action =="LIST DEPENDENCIES":
            return gr.update(visible=False),gr.update(choices=[],value=None),gr.update(visible=True)
        return gr.update(visible=False),gr.update(visible=False)
    def class_action_selected_by_user(repository,class_name,action,progress=gr.Progress(track_tqdm=True)):
        if not class_name:
            gr.Warning("Please Select a class first!")
            return gr.update(visible=False),gr.update(visible=False),None,None,gr.update(visible=False)
        if action == "SHOW DEPENDENCIES":
            progress(0.1,desc="Querying dependencies...")
            query=f"MATCH (c:Class {{name: '{class_name}}})-[r:HAS_METHOD]->(m:Method)-[r2:CALLS_METHOD]->(target:Method) RETURN c.name as Class,m.name as Method,type(r2)as Action,target.name as CalledMethod"
            result=query_handler.extract_result_for_query(query)
            if result:
                df=pd.DataFrame(result)
                html_code=df.to_html(index=False,justify='center',border=1,classes="gr-dataframe")
            else:
                html_code="<p style='text-align:center;color:gray;'>No dependencies found for this class.</p>"
            return gr.update(visible=True),gr.update(visible=False),html_code,gr.update(choices=[],value=None),None,gr.update(visible=False)
        elif action == "SHOW METHODS":
            progress(0.1,desc="Querying methods...")
            query=f"MATCH (c:Class {{name: '{class_name}'}})-[:HAS_METHOD]->(m:Method) RETURN m.name as name"
            result=query_handler.extract_result_for_query(query)
            methods=[x["m.name"] for x in result] if result else []
            return gr.update(visible=False),gr.update(visible=True),None,gr.update(choices=methods,value=None),gr.update(visible=True)
        return gr.update(visible=False),gr.update(visible=False),None,gr.update(choices=[],value=None),gr.update(visible=False)

    # --- START: PROGRESS INDICATOR IMPLEMENTATION ---
    # 1. Explanation: The function is converted to a generator using `yield`.
    # This allows it to send multiple UI updates for a single button click.
    def explain_code_button_handler(selected_methods, class_name):
        if not selected_methods:
            gr.Warning("Please select at least one method to explain.")
            # We return 4 values to match the number of outputs for this function.
            # The button state is unchanged, so we pass gr.update() for it.
            return gr.update(visible=False), None, None, gr.update()

        method_to_explain = selected_methods[0]
        query = f"MATCH (c:Class {{name: '{class_name}'}})-[:HAS_METHOD]->(m:Method {{name: '{method_to_explain}'}}) RETURN m.source as source"
        result = query_handler.extract_result_for_query(query)

        if result and "source" in result[0]:
            source_code = result[0]["source"]
            
            # 2. Explanation: FIRST YIELD - The "loading" state.
            # This is sent to the UI immediately. The button is disabled and its text changes.
            # The output area becomes visible with a loading message.
            yield {
                code_explanation_tab: gr.update(visible=True),
                code_output: gr.update(value=source_code),
                explanation_output: gr.update(value="*Please wait, the LLM is thinking...*"),
                explain_code_button: gr.update(value="Generating Explanation...", interactive=False)
            }

            # This is the slow part that runs after the UI has been updated.
            code_explanation = query_handler.explain_code(source_code)

            # 3. Explanation: FINAL YIELD (or return) - The "finished" state.
            # This is sent after the slow process completes. It populates the final data
            # and resets the button back to its original, interactive state.
            yield {
                code_explanation_tab: gr.update(visible=True),
                code_output: gr.update(value=source_code),
                explanation_output: gr.update(value=code_explanation),
                explain_code_button: gr.update(value="Explain Selected Code", interactive=True)
            }
        else:
            gr.Error("Could not retrieve source code for the selected method.")
            # Return the final state, ensuring the button is interactive.
            yield {
                code_explanation_tab: gr.update(visible=False),
                code_output: None,
                explanation_output: None,
                explain_code_button: gr.update(value="Explain Selected Code", interactive=True)
            }
    # --- END: PROGRESS INDICATOR IMPLEMENTATION ---

    def handle_nlp_query(question, history, progress=gr.Progress(track_tqdm=True)):
        if not question or not question.strip():
            gr.Warning("Please enter a question before running the query.")
            return "", history, history, gr.update(), ""

        progress(0, desc="Identifying Intent...")
        bot_response = ""
        try:
            res = query_handler.identify_intent(question)
            res = res.strip('`').strip('json')
            if not res.strip():
                raise ValueError("Received an empty response from identify_intent")
            response_json = json.loads(res)
            intent = response_json.get("intent")
        except (json.JSONDecodeError, ValueError) as e:
            error_message = f"Failed to parse response from the language model: {e}"
            print(error_message)
            gr.Error(error_message)
            bot_response = f"<p style='color:red;'>Error: Could not understand the model's response. Details: {html.escape(str(e))}</p>"
            history.append([question, bot_response])
            return "", history, history, gr.update(visible=True), bot_response

        if intent == "dependency":
            progress(0.3, desc="Generating & running Cypher query...")
            result_data = query_handler.run_query(question)
            
            final_answer = result_data.get("result")
            df_markdown = ""
            if isinstance(final_answer, list) and final_answer:
                df = pd.DataFrame(final_answer)
                df_markdown = "### Query Result\n" + df.to_markdown(index=False) + "\n\n<hr>"

            intermediate_html = "<h3>Query Execution Details</h3>"
            intermediate_html += f"<b>Original Question:</b><p><i>{html.escape(result_data.get('question', 'N/A'))}</i></p>"
            for step in result_data.get('intermediate_steps', []):
                status_color = 'green' if step['status'] == 'Success' else 'red'
                intermediate_html += f"<hr><b>Attempt {step['attempt']}: <span style='color:{status_color};'>{step['status']}</span></b>"
                intermediate_html += f"<pre><code class='language-cypher'>{html.escape(step['cypher_query'])}</code></pre>"
                if step['status'] != 'Success':
                    intermediate_html += f"<p style='color:red;'><b>Error:</b> {html.escape(str(step['error']))}</p>"
            if not df_markdown:
                 intermediate_html += "<hr><b>Final answer:</b><p>Query executed successfully but returned no results.</p>"
            
            bot_response = df_markdown + intermediate_html
        else:
            progress(0.3, desc="Extracting entities...")
            entities_str = query_handler.extract_entities(question)
            entities_arr = [e.strip() for e in entities_str.split(",") if e.strip()]
            progress(0.6, desc="Querying graph for entities...")
            query = f"WITH {json.dumps(entities_arr)} AS names MATCH (n) WHERE n.name IN names RETURN n"
            result = query_handler.extract_result_for_query(query=query)
            
            explanation_html = "<h3>Code Explanations</h3>"
            if not result:
                explanation_html += "<p>Could not find any matching code elements for the entities found.</p>"
            else:
                for item in progress.tqdm(result, desc="Generating explanations..."):
                    node = item.get("n", {})
                    if 'source' in node and 'name' in node:
                        code_explanation = query_handler.explain_code(node["source"])
                        escaped_source = html.escape(node["source"])
                        explanation_html += f"<hr><h4>Explanation for: <code>{html.escape(node['name'])}</code></h4>"
                        explanation_html += f"<pre><code>{escaped_source}</code></pre>"
                        explanation_html += f"<div>{code_explanation}</div>"
            bot_response = explanation_html

        history.append([question, bot_response])
        
        return "", history, history, gr.update(visible=True), bot_response
    
    all_components=[main_page]+guided_mode_components+nlp_mode_components
    user_option.change(
        fn=navigation,
        inputs=user_option,
        outputs=all_components
    )
    repository_radio.change(fn=repository_selected_by_user,inputs=None,outputs=[repository_action_row])
    repository_action.change(fn=repository_action_selected_by_user,inputs=[repository_radio,repository_action],outputs=[list_class_row,classes_radio_group,list_dependencies_row])
    classes_radio_group.change(fn=class_selected_by_user,inputs=None,outputs=[class_action_row])
    class_action_radio_group.change(fn=class_action_selected_by_user,inputs=[repository_radio,classes_radio_group,class_action_radio_group],outputs=[dependencies_row,method_row,html_code_output,method_checkbox_group,explain_code_row])
    
    # --- START: PROGRESS INDICATOR IMPLEMENTATION ---
    # 4. Explanation: The event listener is updated.
    # The button itself (`explain_code_button`) is now included in its own inputs and outputs.
    # This is necessary so the handler function can receive its state and send updates back to it.
    explain_code_button.click(
        fn=explain_code_button_handler,
        inputs=[method_checkbox_group, classes_radio_group],
        outputs=[code_explanation_tab, code_output, explanation_output, explain_code_button]
    )
    # --- END: PROGRESS INDICATOR IMPLEMENTATION ---

    history_button.click(
        fn=toggle_history_visibility,
        inputs=[history_visible_state],
        outputs=[history_display_row, history_visible_state]
    )

    nlp_textbox.submit(
        fn=handle_nlp_query,
        inputs=[nlp_textbox, chatbot_history_state],
        outputs=[nlp_textbox, chatbot_output, chatbot_history_state, nlp_results_col, current_response_output]
    )
    nlp_run_button.click(
        fn=handle_nlp_query,
        inputs=[nlp_textbox, chatbot_history_state],
        outputs=[nlp_textbox, chatbot_output, chatbot_history_state, nlp_results_col, current_response_output]
    )

demo.launch(debug=True)
