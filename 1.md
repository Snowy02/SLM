Of course. I will now integrate session-based chat history into the "I know what I am doing" user path.

The core changes involve introducing a gr.State component to hold the conversation history, replacing the separate output components with a unified gr.Chatbot for a better user experience, and modifying the backend function to append new interactions to this state. This creates a persistent and clear chat log that resets with each new session, fulfilling all your requirements.

Here is the complete, updated code:

Generated python
#here lies the code of gradio 
import gradio as gr
import pandas as pd
import json
from graph_query_handler import GraphQueryHandler
from data_structures import Node
from typing import Dict,List
import html

custom_theme=gr.themes.Default(
    primary_hue="blue",
    secondary_hue="green",
    neutral_hue="orange",
    text_size="sm",
    font="Comic Sans MS"
)

title_html="""
<div style="text-align: center; margin-top:20px;">
    <h1 style="background: linear-gradient(to right,red,orange,yellow,green,blue,indigo,violet); -webkit-background-clip: text; color:transparent;">
        Codebase Analytica
    </h1>
    <p style="font-size: 18px; color: gray;">Decoding Complexity, One Line at a Time</p>
</div>
"""

def get_query_handler():
    try:
        return GraphQueryHandler()
    except ConnectionError as e:
        print("Error: ",e)
        gr.Error(f"**Failed to initiate connection:** {e}",duration=5)
    return None
query_handler=get_query_handler()
if not query_handler:
    with gr.Blocks(theme=custom_theme)as demo:
        gr.HTML(title_html)
        gr.Error("Could not connect to the database")
    demo.launch()
    import sys
    sys.exit()
with gr.Blocks(theme=custom_theme) as demo:
    # --- START: CHAT HISTORY IMPLEMENTATION ---
    # 1. Explanation: Add a state component to store the chat history.
    # This component is not visible in the UI but holds the conversation data
    # as a list of [user_prompt, bot_response] pairs for the entire session.
    chatbot_history_state = gr.State([])
    # --- END: CHAT HISTORY IMPLEMENTATION ---

    gr.HTML(title_html)
    with gr.Sidebar():
        gr.Label("Graph Schema")
        gr.Markdown("A concise summary of the graph schema")
        gr.Markdown(query_handler.concise_schema)
    with gr.Row(visible=True)as main_page:
        user_option=gr.Radio(
            choices=["I am new to Marketplace","I know what I am doing"],
            interactive=True,
            label="Who are you?"
        )
    with gr.Row(visible=False)as repository_row:
        query_for_repositories="MATCH (n:Repository) RETURN DISTINCT n"
        repository_nodes=query_handler.extract_result_for_query(query_for_repositories)
        repositories=[x["n"]["name"] for x in repository_nodes] if repository_nodes else []
        repository_radio=gr.Radio(repositories,label="Select Repository",interactive=True)
    with gr.Row(visible=False)as repository_action_row:
        REPOSITORY_ACTIONS=["LIST CLASSES","LIST DEPENDENCIES"]
        repository_action=gr.Radio(REPOSITORY_ACTIONS,label="What would you like to do?",interactive=True)
    with gr.Row(visible=False)as list_class_row:
        classes_radio_group=gr.Radio(choices=[],label="Select a Class",interactive=True)
    with gr.Row(visible=False)as list_dependencies_row:
        gr.Markdown("Dependency features for the entire repository can be complex. Please select a specific class first to see its dependencies.")
    with gr.Row(visible=False)as class_action_row:
        CLASS_ACTION=['SHOW METHODS','SHOW DEPENDENCIES']
        class_action_radio_group=gr.Radio(CLASS_ACTION,label="Select Action for the chosen class",interactive=True)
    with gr.Row(visible=False)as dependencies_row:
        html_code_output=gr.HTML(label="Class Dependencies")
    with gr.Row(visible=False)as method_row:
        method_checkbox_group=gr.CheckboxGroup(choices=[],label="Select Method to Explain")
    with gr.Row(visible=False)as explain_code_row:
        explain_code_button=gr.Button(variant="primary",value="Explain Selected Code",interactive=True)
    with gr.Tab(label="Code Explanation",visible=False)as code_explanation_tab:
        with gr.Row():
            code_output=gr.Code(label="Source Code",language="python",interactive=False,scale=1)
            explanation_output=gr.Markdown("LLM Explanation")
    with gr.Row(visible=False)as nlp_mode_row:
        with gr.Column():
            gr.Markdown("## Codebase Knowledge Graph Explorer")
            gr.Markdown("Ask a question about your codebase is natural language.The system will convert it to a Cypher query,execute it, and return the answer.")
            with gr.Row():
                nlp_textbox=gr.Textbox(label="Enter your question here:",lines=4,scale=7, placeholder="e.g., 'What are the dependencies for the class X?'")
                nlp_run_button=gr.Button("Run Query",variant="primary",scale=1)
            
            # --- START: CHAT HISTORY IMPLEMENTATION ---
            # 2. Explanation: Replace separate output components with a single Chatbot.
            # This Chatbot component provides a clean, conversational interface.
            # 'autoscroll=True' is a bonus feature that ensures the view scrolls to the latest message.
            with gr.Column(visible=False) as nlp_results_col:
                chatbot_output = gr.Chatbot(
                    label="Conversation History",
                    bubble_full_width=False,
                    autoscroll=True,
                    height=500 # Set a fixed height for better layout
                )
            # --- END: CHAT HISTORY IMPLEMENTATION ---

    guided_mode_components=[
        repository_row,repository_action_row,list_class_row,list_dependencies_row,
        class_action_row,dependencies_row,method_row,explain_code_row,code_explanation_tab
    ]
    # --- START: CHAT HISTORY IMPLEMENTATION ---
    # 3. Explanation: Add the new chatbot components to the list of components.
    # This allows the navigation function to control their state (e.g., visibility, value).
    nlp_mode_components=[nlp_mode_row, nlp_results_col, chatbot_output, chatbot_history_state]
    # --- END: CHAT HISTORY IMPLEMENTATION ---

    def navigation(option):
        updates={}
        updates[main_page]=gr.update(visible=False)
        if option == "I am new to Marketplace":
            updates[repository_row]=gr.update(visible=True)
            for comp in guided_mode_components[1:]+nlp_mode_components:
                updates[comp]=gr.update(visible=False)
            # --- START: CHAT HISTORY IMPLEMENTATION ---
            # 4. Explanation: Reset chat history when switching away from the NLP mode.
            updates[chatbot_history_state] = []
            updates[chatbot_output] = []
            # --- END: CHAT HISTORY IMPLEMENTATION ---
        elif option == "I know what I am doing":
            updates[nlp_mode_row]=gr.update(visible=True) # Corrected typo from 'vsisible'
            for comp in guided_mode_components:
                updates[comp]=gr.update(visible=False)
            # --- START: CHAT HISTORY IMPLEMENTATION ---
            # 5. Explanation: Ensure chat history is reset when entering the NLP mode.
            updates[chatbot_history_state] = []
            updates[chatbot_output] = []
            updates[nlp_results_col] = gr.update(visible=False) # Hide results column on switch
            # --- END: CHAT HISTORY IMPLEMENTATION ---
        return updates
    
    def repository_selected_by_user():
        return gr.update(visible=True,value=None)
    def class_selected_by_user():
        return gr.update(visible=True,value=None)
    def repository_action_selected_by_user(repository,action):
        if action =="LIST CLASSES":
            query=f"MATCH(n:Repository {{name: '{repository}'}})-[HAS_CLASSES]->(c:Class) RETURN c.name as name"
            result=query_handler.extract_result_for_query(query)
            classes=[x["c"]["name"] for x in result] if result else []
            return gr.update(visible=True),gr.update(choices=classes,value=None),gr.update(visible=False)
        elif action =="LIST DEPENDENCIES":
            return gr.update(visible=False),gr.update(choices=[],value=None),gr.update(visible=True)
        return gr.update(visible=False),gr.update(visible=False)
    def class_action_selected_by_user(repository,class_name,action,progress=gr.Progress(track_tqdm=True)):
        if not class_name:
            gr.Warning("Please Select a class first!")
            return gr.update(visible=False),gr.update(visible=False),None,None,gr.update(visible=False)
        if action == "SHOW DEPENDENCIES":
            progress(0.1,desc="Querying dependencies...")
            query=f"MATCH (c:Class {{name: '{class_name}}})-[r:HAS_METHOD]->(m:Method)-[r2:CALLS_METHOD]->(target:Method) RETURN c.name as Class,m.name as Method,type(r2)as Action,target.name as CalledMethod"
            result=query_handler.extract_result_for_query(query)
            if result:
                df=pd.DataFrame(result)
                html_code=df.to_html(index=False,justify='center',border=1,classes="gr-dataframe")
            else:
                html_code="<p style='text-align:center;color:gray;'>No dependencies found for this class.</p>"
            return gr.update(visible=True),gr.update(visible=False),html_code,gr.update(choices=[],value=None),None,gr.update(visible=False)
        elif action == "SHOW METHODS":
            progress(0.1,desc="Querying methods...")
            query=f"MATCH (c:Class {{name: '{class_name}'}})-[:HAS_METHOD]->(m:Method) RETURN m.name as name"
            result=query_handler.extract_result_for_query(query)
            methods=[x["m.name"] for x in result] if result else []
            return gr.update(visible=False),gr.update(visible=True),None,gr.update(choices=methods,value=None),gr.update(visible=True)
        return gr.update(visible=False),gr.update(visible=False),None,gr.update(choices=[],value=None),gr.update(visible=False)
    def explain_code_button_handler(selected_methods,repository,class_name):
        if not selected_methods:
            gr.Warning("Please select at least one method to explain")
            return gr.update(visible=False),None,None
        method_to_explain=selected_methods[0]
        query=f"MATCH (c:Class {{name: '{class_name}'}})-[:HAS_METHOD]->(m:Method {{name: '{method_to_explain}'}}) RETURN m.source as source"
        result=query_handler.extract_result_for_query(query)
        if result and "source" in result[0]:
            source_code=result[0]["source"]
            code_explanation=query_handler.explain_code(source_code)
            return gr.update(visible=True),gr.update(value=source_code),gr.update(value=code_explanation)
        else:
            gr.Error("Could not retrieve source code for the selected method.")
            return gr.update(visible=False),None,None

    # --- START: CHAT HISTORY IMPLEMENTATION ---
    # 6. Explanation: Modify the handler function to manage chat history.
    # - It now accepts `history` from the `chatbot_history_state`.
    # - It constructs a single bot response string instead of updating multiple components.
    # - It appends the [user_prompt, bot_response] pair to the history.
    # - It returns the updated history to both the state and the chatbot UI.
    def handle_nlp_query(question, history, progress=gr.Progress(track_tqdm=True)):
        if not question or not question.strip():
            gr.Warning("Please enter a question before running the query.")
            # Return original history unchanged, clear textbox, and don't change column visibility
            return "", history, history, gr.update()
        
        progress(0, desc="Identifying Intent...")
        bot_response = ""
        try:
            res=query_handler.identify_intent(question)
            res=res.strip('`').strip('json')
            if not res.strip():
                raise ValueError("Received an empty response from identify_intent")
            response_json=json.loads(res)
            intent=response_json.get("intent")
        except (json.JSONDecodeError, ValueError) as e:
            error_message = f"Failed to parse response from the language model: {e}"
            print(error_message)
            gr.Error(error_message)
            bot_response = f"<p style='color:red;'>Error: Could not understand the model's response. Details: {html.escape(str(e))}</p>"
            history.append([question, bot_response])
            return "", history, history, gr.update(visible=True)

        if intent == "dependency":
            progress(0.3, desc="Generating & running Cypher query...")
            result_data = query_handler.run_query(question)
            
            final_answer = result_data.get("result")
            df_markdown = ""
            if isinstance(final_answer, list) and final_answer:
                df = pd.DataFrame(final_answer)
                # Convert DataFrame to Markdown for clean display in the chatbot
                df_markdown = "### Query Result\n" + df.to_markdown(index=False) + "\n\n<hr>"

            intermediate_html = "<h3>Query Execution Details</h3>"
            intermediate_html += f"<b>Original Question:</b><p><i>{html.escape(result_data.get('question', 'N/A'))}</i></p>"
            for step in result_data.get('intermediate_steps', []):
                status_color = 'green' if step['status'] == 'Success' else 'red'
                intermediate_html += f"<hr><b>Attempt {step['attempt']}: <span style='color:{status_color};'>{step['status']}</span></b>"
                intermediate_html += f"<pre><code class='language-cypher'>{html.escape(step['cypher_query'])}</code></pre>"
                if step['status'] != 'Success':
                    intermediate_html += f"<p style='color:red;'><b>Error:</b> {html.escape(str(step['error']))}</p>"

            if not df_markdown:
                 intermediate_html += "<hr><b>Final answer:</b><p>Query executed successfully but returned no results.</p>"
            
            bot_response = df_markdown + intermediate_html

        else: # Assumes 'code_explanation' intent
            progress(0.3, desc="Extracting entities...")
            entities_str = query_handler.extract_entities(question)
            entities_arr = [e.strip() for e in entities_str.split(",") if e.strip()]
            progress(0.6, desc="Querying graph for entities...")
            query = f"WITH {json.dumps(entities_arr)} AS names MATCH (n) WHERE n.name IN names RETURN n"
            result = query_handler.extract_result_for_query(query=query)
            
            explanation_html = "<h3>Code Explanations</h3>"
            if not result:
                explanation_html += "<p>Could not find any matching code elements for the entities found.</p>"
            else:
                for item in progress.tqdm(result, desc="Generating explanations..."):
                    node = item.get("n", {})
                    if 'source' in node and 'name' in node:
                        code_explanation = query_handler.explain_code(node["source"])
                        escaped_source = html.escape(node["source"])
                        explanation_html += f"<hr><h4>Explanation for: <code>{html.escape(node['name'])}</code></h4>"
                        explanation_html += f"<pre><code>{escaped_source}</code></pre>"
                        explanation_html += f"<div>{code_explanation}</div>"
            bot_response = explanation_html

        # Append the user's question and the final bot response to the history
        history.append([question, bot_response])
        
        # Return updates: clear textbox, update chatbot UI, update history state, and make results visible
        return "", history, history, gr.update(visible=True)
    # --- END: CHAT HISTORY IMPLEMENTATION ---
    
    all_components=[main_page]+guided_mode_components+nlp_mode_components
    user_option.change(
        fn=navigation,
        inputs=user_option,
        outputs=all_components
    )
    repository_radio.change(fn=repository_selected_by_user,inputs=None,outputs=[repository_action_row])
    repository_action.change(fn=repository_action_selected_by_user,inputs=[repository_radio,repository_action],outputs=[list_class_row,classes_radio_group,list_dependencies_row])
    classes_radio_group.change(fn=class_selected_by_user,inputs=None,outputs=[class_action_row])
    class_action_radio_group.change(fn=class_action_selected_by_user,inputs=[repository_radio,classes_radio_group,class_action_radio_group],outputs=[dependencies_row,method_row,html_code_output,method_checkbox_group,explain_code_row])
    explain_code_button.click(fn=explain_code_button_handler,inputs=[method_checkbox_group,repository_radio,classes_radio_group],outputs=[code_explanation_tab,code_output,explanation_output])

    # --- START: CHAT HISTORY IMPLEMENTATION ---
    # 7. Explanation: Update event listeners to handle the new stateful chat flow.
    # The `inputs` now include the `chatbot_history_state`.
    # The `outputs` now target the `chatbot_output` and its `chatbot_history_state`, along with the textbox and results column.
    nlp_textbox.submit(
        fn=handle_nlp_query,
        inputs=[nlp_textbox, chatbot_history_state],
        outputs=[nlp_textbox, chatbot_output, chatbot_history_state, nlp_results_col]
    )
    nlp_run_button.click(
        fn=handle_nlp_query,
        inputs=[nlp_textbox, chatbot_history_state],
        outputs=[nlp_textbox, chatbot_output, chatbot_history_state, nlp_results_col]
    )
    # --- END: CHAT HISTORY IMPLEMENTATION ---

demo.launch(debug=True)
