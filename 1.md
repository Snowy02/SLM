Understood perfectly. You want the simplest, least disruptive change possible:

No new components in the UI.

No changes to the existing UI layout.

When the user clicks "CLASS DIAGRAM", the browser will automatically download a PNG file of the diagram.

This is an excellent approach because it's clean, doesn't mess with the UI, and gives the user a useful artifact. We can achieve this with Gradio's gr.File component.

Here is the plan:

Add a gr.File Component: We will add a single, hidden gr.File component to our UI.

Update the Python Function: We'll modify the "CLASS DIAGRAM" part of the function to generate the PNG and then return an update to make the gr.File component visible and point to our new image. The browser will then automatically show a download link.

Update the Event Handler: We'll add the new gr.File component to the outputs list.

Step 1: Add the gr.File Component (Additive)

➡️ In web.py, find the block for your other outputs (around line 69) and add the gr.File component after them.

Generated python
# (Your code around line 68)
with gr.Row(visible=False) as class_diagram_row:
    class_diagram_row = gr.Markdown(value="")

# --- ADD THIS NEW LINE ---
diagram_download = gr.File(label="Download Class Diagram", visible=False)
# --- END ADDITION ---

# (The rest of your code, starting with `with gr.Row(visible=False) as class_action_row:`)


This component will automatically create a download button when we give it a file path.

Step 2: Update the repository_action_selected_by_user Function

We will replace your function with a version that correctly handles the image generation and the new download component. This is the safest way to ensure all return values are correct.

➡️ In web.py, replace your entire repository_action_selected_by_user function (lines 141-193) with this complete, corrected version:

Generated python
# --- Make sure these imports are at the top of your web.py file ---
import subprocess
import tempfile
import re
import pandas as pd
# ---

# --- REPLACE your entire function with this ---

def repository_action_selected_by_user(repository, action):
    # This function now returns 4 updates for:
    # 1. list_class_row
    # 2. repo_dependency_output
    # 3. class_diagram_row (your original, which we will now ignore)
    # 4. diagram_download (the new File component)

    # --- Logic for "LIST CLASSES" and "LIST DEPENDENCIES" ---
    if not repository:
        gr.Warning("Please select a repository first.")
        # Hide all four outputs
        return gr.update(visible=False), gr.update(visible=False), gr.update(visible=False), gr.update(visible=False)

    if action == "LIST CLASSES":
        query = f"MATCH (r:Repository {{name: '{repository}'}})-[:HAS_CLASSES]->(c:Class) RETURN c.name as name"
        result = query_handler.extract_result_for_query(query)
        classes = [x['name'] for x in result] if result else []
        return gr.update(visible=True, value=classes), gr.update(visible=False), gr.update(visible=False), gr.update(visible=False)

    elif action == "LIST DEPENDENCIES":
        query = f"MATCH (r:Repository {{name: '{repository}'}})-[:DEPENDS_ON]->(dep:Repository) RETURN dep.name as `Depends On`"
        result = query_handler.extract_result_for_query(query)
        output_df = pd.DataFrame(result) if result else "No dependencies found."
        return gr.update(visible=False), gr.update(visible=True, value=output_df), gr.update(visible=False), gr.update(visible=False)

    elif action == "CLASS DIAGRAM":
        query = f"MATCH (n:Repository {{name: '{repository}'}})-[r1]->(c:Class)-[r2]->(m:Method) return n,r1,c,r2,m"
        result = query_handler.extract_result_for_query(query)
        
        # (Your correct Mermaid text generation logic goes here...)
        if not result:
            output_string = "No classes or methods found."
            # Here, we can optionally show the message in the old markdown row
            return gr.update(visible=False), gr.update(visible=False), gr.update(visible=True, value=output_string), gr.update(visible=False)
        else:
            # ... all your code to generate the 'output_string' with mermaid text ...
            def sanitize_mermaid_name(name):
                if not isinstance(name, str): name = str(name)
                return re.sub(r'[^a-zA-Z0-9_]', '_', name)
            methods_by_class = {}
            for row in result:
                class_name = sanitize_mermaid_name(row['c']['name'])
                method_name = row['m']['name']
                return_type = sanitize_mermaid_name(row['m'].get('return_type', 'void'))
                if class_name not in methods_by_class: methods_by_class[class_name] = []
                methods_by_class[class_name].append(f"+{method_name}() : {return_type}")
            mermaid_lines = ["```mermaid", "classDiagram"]
            for class_name, methods in methods_by_class.items():
                if not class_name: continue
                mermaid_lines.append(f"    class {class_name} {{")
                for method_signature in methods: mermaid_lines.append(f"        {method_signature}")
                mermaid_lines.append("    }")
            mermaid_lines.append("```")
            output_string = "\n".join(mermaid_lines)
        
        # --- NEW PNG GENERATION AND DOWNLOAD LOGIC ---
        try:
            with tempfile.NamedTemporaryFile(delete=False, mode='w', suffix='.mmd') as mmd_file:
                mmd_file.write(output_string)
                mmd_filepath = mmd_file.name
            
            # Name the output PNG after the repository
            png_filepath = f"{repository}_class_diagram.png"

            # Run the mermaid-cli tool
            subprocess.run(
                ["mmdc", "-i", mmd_filepath, "-o", png_filepath, "-w", "1200"],
                check=True, shell=True
            )

            # Return an update to show the download component
            return gr.update(visible=False), gr.update(visible=False), gr.update(visible=False), gr.update(visible=True, value=png_filepath)

        except Exception as e:
            print(f"Error generating diagram: {e}")
            error_msg = "Error: Could not generate diagram image. Check terminal for details."
            return gr.update(visible=False), gr.update(visible=False), gr.update(visible=True, value=error_msg), gr.update(visible=False)

    # Default case
    return gr.update(visible=False), gr.update(visible=False), gr.update(visible=False), gr.update(visible=False)

# --- END OF REPLACEMENT ---
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Python
IGNORE_WHEN_COPYING_END
Step 3: Update the Event Handler

Finally, add the new diagram_download component to the outputs list for the correct event handler.

➡️ Find line 469 and modify it to include the new component:

Generated python
repository_action.change(
    fn=repository_action_selected_by_user,
    inputs=[repository_radio, repository_action],
    # --- MODIFY THIS LINE ---
    outputs=[list_class_row, repo_dependency_output, class_diagram_row, diagram_download]
    # --- END MODIFICATION ---
)
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Python
IGNORE_WHEN_COPYING_END

Result:
Now, your UI will remain unchanged. When a user selects a repository and clicks "CLASS DIAGRAM", a file download link will appear labeled "Download Class Diagram", allowing them to save the PNG directly. This is a very clean and effective solution.
